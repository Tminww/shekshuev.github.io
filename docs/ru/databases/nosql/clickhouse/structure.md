# Структура базы данных

## Основные движки таблиц в ClickHouse

ClickHouse предлагает разнообразные движки таблиц, каждый из которых оптимизирован для определенных сценариев использования. Движок таблицы определяет ключевые аспекты работы с данными: способ хранения, поддерживаемые типы запросов, возможности индексации, многопоточность и репликацию.

| ENGINE          | SELECT    | INSERT | DELETE | UPDATE | persistent | indexes |
| --------------- | --------- | ------ | ------ | ------ | ---------- | ------- |
| \*MergeTree     | +         | +      | +      | +      | +          | +       |
| \*Log           | +         | +      | +      | -      | +          | -       |
| EmbeddedRocksDB | +         | +      | +      | -      | +          | -       |
| URL             | +         | -/+    | -      | -      | external   | -       |
| Buffer          | +         | +      | -      | -      | +          | -       |
| Memory          | +         | +      | +      | +      | -          | -       |
| Set             | (only IN) | -      | -      | -      | +          | -       |
| Join            | +         | -      | -      | -      | +          | -       |
| PostgreSQL      | +         | +      | -      | -      | external   | -       |
| Kafka           | +         | -      | -      | -      | external   | -       |

Примечания:

- `+` - поддерживается

- `-` - не поддерживается

- `- / +` - частичная поддержка или зависит от конфигурации

- `external` - данные хранятся во внешней системе

- `(only IN)` - поддерживается только операция IN

- `persistent` - "постоянное хранение" (указывает, сохраняются ли данные на диск или во внешней системе)

- `indexes` - "индексы" (указывает, поддерживает ли движок индексацию данных)

## Семейство движков \*MergeTree

Движки семейства \*MergeTree - это основа ClickHouse и наиболее часто используемый тип таблиц в этой СУБД. Они предназначены для хранения больших объёмов данных на диске в сжатом виде и поддерживают полный набор операций DML: `SELECT`, `INSERT`, `DELETE`, `UPDATE`. Благодаря этому можно не только читать и добавлять данные, но и выполнять их удаление и обновление.

Ключевая особенность MergeTree - поддержка индексов, в том числе уникальных для ClickHouse индексов пропуска данных (разреженных индексов). Эти индексы позволяют эффективно фильтровать данные и ускоряют выполнение аналитических запросов на больших таблицах. Таблицы MergeTree могут быть оптимизированы с помощью партиционирования и сортировки по ключу, что дополнительно увеличивает производительность при работе с большими объёмами информации.

## Разновидности движков семейства MergeTree

Семейство MergeTree в ClickHouse включает несколько разновидностей движков, каждая из которых обладает своей спецификой и дополнительными возможностями.

### Базовый MergeTree

Движок MergeTree является локальной таблицей, которая хранит данные на диске в исходном виде без каких-либо дополнительных преобразований. Он обеспечивает эффективное хранение и быстрый доступ к данным, поддерживает операции вставки, чтения, удаления и обновления, а также использование разреженных индексов для ускорения запросов.

### Расширенные движки на базе MergeTree

Помимо базового MergeTree, существуют движки, которые наследуют его архитектуру хранения данных, но добавляют специальные механизмы, работающие во время фонового процесса слияния данных (merge). Эти механизмы позволяют реализовать дополнительные функции, такие как агрегация и дедупликация.

- **AggregatingMergeTree** и **SummingMergeTree** - используются для хранения агрегированных данных, например, суммарных значений за разные периоды. Они позволяют автоматически агрегировать данные при слиянии частей таблицы, что упрощает и ускоряет аналитические вычисления.

- **ReplacingMergeTree** - предназначен для автоматического удаления дубликатов записей, оставляя только последнюю версию данных по ключу. Это полезно, когда данные могут обновляться путём вставки новых версий.

- **CollapsingMergeTree (с параметром sign)** - реализует механизм «свёртывания» строк с противоположными значениями sign, что позволяет эффективно удалять отменённые записи и поддерживать консистентность данных.

- **VersionedCollapsingMergeTree** - расширяет возможности CollapsingMergeTree, добавляя поддержку версионирования записей для более точного контроля обновлений и удаления.

Рассмотрим их подробнее.

## Движок SummingMergeTree

Движок SummingMergeTree предназначен для хранения данных с автоматической агрегацией по сумме значений в определённых числовых столбцах. Основной принцип работы этого движка заключается в том, что при слиянии частей таблицы все строки, имеющие одинаковый ключ сортировки (первичный ключ), объединяются в одну запись. При этом для указанных в параметрах движка числовых столбцов происходит суммирование значений.

В отличие от AggregatingMergeTree, который поддерживает широкий набор агрегатных функций, SummingMergeTree умеет работать только с операцией суммирования.

Для столбцов, входящих в ключ сортировки, значения остаются без изменений, так как они определяют уникальность записи. Для остальных столбцов, не участвующих в суммировании и не входящих в ключ, выбирается одно из значений, случайным образом взятое из объединяемых строк.

Если в таблице используются вложенные структуры (например, вложенные массивы или объекты), суммирование происходит по соответствующим полям внутри этих структур.

Для получения окончательных агрегированных данных, учитывающих все слияния, можно использовать модификатор `FINAL` в операторе `SELECT`. Это позволяет получить результат, в котором все промежуточные части данных, ещё не объединённые в процессе слияния, будут учтены.

Выполните код, чтобы создать таблицу и добавить в неё данные.

```sql
CREATE TABLE summing_mt
(
    id UInt32,
    val UInt32,
    example UInt32,  -- столбец, не входящий в ключ сортировки и параметры движка
)
ENGINE = SummingMergeTree(val) -- сумма будет считаться по полю val, так как оно указано в качестве параметра движка
ORDER BY (id); -- записи по этому ключу будут группироваться

INSERT INTO summing_mt SELECT 1, (number + 1) * 10, (number + 1) * 100 from numbers(3);
INSERT INTO summing_mt SELECT 1, 10, 100;
```

Посмотрите на выборку:

```sql
SELECT * FROM summing_mt;
```

Здесь вы видите два куска, для которых слияние ещё не запустилось.

Теперь обратите внимание на вторую выборку:

```sql
SELECT * FROM summing_mt FINAL;
```

Модификатор `FINAL` выдаст данные, как будто слияние уже произошло.

Альтернативным способом получить актуальные данные является запуск команды `OPTIMIZE` по целевой таблице или по указанной партиции.

```sql
OPTIMIZE TABLE summing_mt FINAL;
SELECT * FROM summing_mt;
```

В результате вы увидите, что после `OPTIMIZE` данные просуммировались.

Для подготовки данных, на основе которых будут строиться отчёты, целесообразно использовать движок SummingMergeTree вместе с обычной MergeTree-таблицей. Такая связка позволяет эффективно агрегировать данные по суммам и при этом сохранять исходные записи.

При чтении данных из нескольких партиций или при выполнении агрегаций важно использовать модификатор `FINAL`. Без него записи из разных партиций не будут объединяться и заменяться корректно, что может привести к некорректным результатам. Это правило действует для всех таблиц семейства MergeTree.

## Движок AggregatingMergeTree

Движок AggregatingMergeTree представляет собой таблицу, которая группирует записи с одинаковым ключом сортировки и применяет к полям агрегатные функции. В отличие от SummingMergeTree, который поддерживает только операцию суммирования, AggregatingMergeTree позволяет использовать широкий набор агрегатов - подсчёт уникальных значений, вычисление среднего, перцентилей и другие.

При создании таблицы с движком AggregatingMergeTree необходимо явно указать агрегатные функции для соответствующих столбцов, чтобы ClickHouse знал, как агрегировать данные при слиянии.

Рассмотрим пример:

```sql
CREATE TABLE agg_mt
(
    id UInt32,
    val SimpleAggregateFunction(max, UInt32) -- агрегатная функция max
)
ENGINE = AggregatingMergeTree
ORDER BY (id);

INSERT INTO agg_mt SELECT 1, (number + 1) * 10 from numbers(3); -- 10, 20, 30

SELECT * FROM agg_mt

INSERT INTO agg_mt SELECT 1, 50;    -- вставка данных в новый кусок

SELECT * FROM agg_mt

```

Последний `SELECT` нам выдал 2 строки, потому что данные вставились в разные куски, а агрегация срабатывает для данных в одному куске. Нужно, чтобы прошло слияние и данные оказались в одном куске. С инструкцией `FINAL` можно увидеть результат, будто слияние уже прошло, вот так:

```sql
SELECT * FROM agg_mt FINAL
```

Получить нужный результат без использования `FINAL` и фоновых слияний `OPTIMIZE` можно, применяя агрегатную функцию в запросе и группируя записи по ключу:

```sql
SELECT id, max(val) as val
FROM agg_mt
GROUP BY id;
```

> [!CAUTION] Внимание
> `FINAL` работает примерно в полтора-два раза медленнее, чем явное указание группировки.

```sql
OPTIMIZE TABLE agg_mt; -- выполнение слияния с помощью OPTIMIZE

SELECT * FROM agg_mt
```

В результате - одна строка, как в запросе с `GROUP BY`.

```sql
INSERT INTO agg_mt SELECT 2, 150;  -- вставка новой записи с другим id

OPTIMIZE TABLE agg_mt;  -- выполнение слияния

SELECT * FROM agg_mt
```

Здесь на выходе получается две строки, так как `ORDER BY (id)`, а у нас id разные.

> [!TIP] Замечание
> Следующие три движка используются в ситуациях, когда исходный MergeTree не подходит из-за низкой производительности, а именно — когда нужно совершать много операций обновления.

## Движок ReplacingMergeTree

Движок ReplacingMergeTree предназначен для удаления дублирующихся записей с одинаковым значением ключа сортировки. В процессе фонового слияния данных (merge) все дубликаты по ключу заменяются на одну запись - последнюю по времени вставки.

Важно понимать, что удаление дубликатов происходит асинхронно и в неопределённый момент времени, поэтому в выборках без использования модификатора `FINAL` могут встречаться дубликаты.

Кроме того, ReplacingMergeTree поддерживает необязательный параметр `ver` - столбец с номером версии. При указании этого параметра движок сохраняет запись с максимальным значением версии для каждого ключа сортировки, что позволяет более точно контролировать, какая версия данных останется после дедупликации.

### Ключевые особенности ReplacingMergeTree:

- Удаляет дубликаты по ключу сортировки при слиянии данных.
- Дедупликация происходит в фоновом режиме и не гарантируется при чтении без `FINAL`.
- Поддерживает параметр версии для выбора актуальной записи.
- Подходит для хранения данных без дубликатов, когда возможна задержка в их удалении.

Чтобы посмотреть на практике, как работает ReplacingMergeTree, создайте таблицу с помощью кода:

```sql
CREATE TABLE replacing_mt
(
    id UInt32,
    val UInt32
)
ENGINE = ReplacingMergeTree
ORDER BY (id);
```

Вставим искусственные данные. Для этого воспользуемся функцией `numbers`

```sql
SELECT 1, (number + 1) * 10 FROM numbers(3);
```

Запрос выполняет выборку из виртуальной таблицы, которую создаёт функция `numbers(3)`. Эта функция генерирует последовательность из трёх чисел: `0`, `1` и `2`. В результате для каждой строки формируется два столбца: первый всегда равен `1`, а второй вычисляется как `(number + 1) * 10`. То есть для каждой строки к текущему значению `number` прибавляется единица, а затем результат умножается на `10`.

Заполним этими данными таблицу:

```sql
INSERT INTO replacing_mt SELECT 1, (number + 1) * 10 from numbers(3);
SELECT * FROM replacing_mt;
```

Обратите внимание, вы вставляли три записи, а вставилась в итоге одна. Это произошло потому, что вставка `INSERT` шла в одном батче и попала в один кусок, то есть replacing отработал сразу. У всех записей `id=1`, поэтому осталась только последняя.

Теперь посмотрите на код ниже:

```sql
INSERT INTO replacing_mt SELECT 1, 3;
SELECT * FROM replacing_mt
SELECT * FROM replacing_mt FINAL
```

Новая вставка произошла в новый кусок. С использованием `FINAL` мы видим результирующий вариант. Асинхронно в фоне запускается слияние, или вы можете форсированно запустить его с помощью `OPTIMIZE`.

Движок ReplacingMergeTree может быть параметризован полем, указывающим на номер строки `ENGINE = ReplacingMergeTree(version_fld)`. Кроме целочисленных типов поля используются для `Date` или `DateTime`. Когда запускается слияние, остаётся строка с максимальным номером `version`.

Рассмотрим пример кода с версионированием:

```sql
CREATE TABLE replacing_mt_v
(
    id UInt32,
    val UInt32,
    version Int32 -- в рамках id останется одна строка с максимальным значением поля version
)
ENGINE = ReplacingMergeTree(version)
ORDER BY (id);
```

Обратите внимание на поле `version` — в рамках id останется одна строка с максимальным значением поля `version`.

## Движок CollapsingMergeTree

Движок CollapsingMergeTree используется для асинхронного удаления пар строк, которые имеют одинаковые значения по ключу сортировки, но противоположные значения в специальном поле `Sign`. Название этого поля можно выбрать любое, главное - указать его при создании таблицы как параметр движка.

Принцип работы следующий:

- Если у двух строк совпадают все значения по ключу сортировки, а в поле `Sign` у одной строки стоит `1` (означает "активная запись"), а у другой - `-1` (означает "отменённая запись" или "удаление"), то такая пара строк будет автоматически "свёрнута" (удалена) в процессе фонового слияния данных.
- CollapsingMergeTree позволяет реализовать логику отмены или удаления записей без явного удаления строк, что удобно для аналитических сценариев.

Рассмотрим пример:

```sql
CREATE TABLE UAct
(
    UserID UInt64,
    PageViews UInt8,
    Duration UInt8,
    Sign Int8
)
ENGINE = CollapsingMergeTree(Sign)
ORDER BY UserID
```

В этом примере приложение фиксирует количество просмотров. Используйте код для эмуляции действий приложения:

```sql
INSERT INTO UAct VALUES (4324182021466249494, 5, 146, 1)
```

Теперь представьте, что пользователь посмотрел страницу ещё раз, и вам нужно зафиксировать новую цифру, то есть произвести `UPDATE`. Приложение должно отправить в таком случае две записи для вставки:

```sql
INSERT INTO UAct
VALUES (4324182021466249494, 5, 146, -1),(4324182021466249494, 6, 185, 1)
```

Строка с `Sign = -1` свернёт старую версию данных. А строка с `Sign = 1` добавит новую. Теперь проверьте выборку с `FINAL` и без него:

```sql
SELECT * FROM UAct;
SELECT * FROM UAct FINAL;
```

Обратите внимание, что после слияния остаётся одна версия записи.

## VersionedCollapsingMergeTree

VersionedCollapsingMergeTree реализует логику CollapsingMergeTree, но использует другой алгоритм удаления строк и адаптирован для многопоточной вставки. Это достигается при помощи дополнительного поля `version`. Движок VersionedCollapsingMergeTree удаляет дублирующиеся записи с одинаковым значением ключа сортировки, за исключением поля sign с учётом версии строки. Этот процесс имеет альтернативное название — сворачивание записей.
Когда выполняется процесс слияния, ClickHouse удаляет каждую пару строк, которые имеют один и тот же первичный ключ и версию, но разный `Sign`. Чтобы получить полностью свёрнутые данные из таблицы, необходимо использовать агрегирование или модификатор `FINAL`.

```sql
CREATE TABLE vcollapsing_mt
(
    id UInt32,
    val String,
    sign Int8,
    version UInt8 -- удаляет каждую пару строк, которые имеют один и тот же первичный ключ, версию и разный sign
)
ENGINE = VersionedCollapsingMergeTree(sign, version)
ORDER BY (id);

```

После этого добавьте в таблицу две записи с одинаковым `id`, равным единице. Строки будут различаться значением поля `sign`: у первой строки `1`, у второй строки `-1`.
Это означает удаление предыдущей строки в рамках `id`, у которой совпадает значение поля `version`.

```sql
INSERT INTO vcollapsing_mt SELECT 1, 'state_1', 1, 1;
INSERT INTO vcollapsing_mt SELECT 1, 'cancel state', -1, 1;
```

Теперь проверьте вставку и результат слияния:

```sql
SELECT * FROM vcollapsing_mt;
SELECT * FROM vcollapsing_mt FINAL
```

На примере видно, что если выполнить выборку из таблицы `vcollapsing_mt FINAL`, то выборка не вернёт записи, потому что тут подразумевается удаление вставленной записи.

Разберём значения поля `sign:

- Если `sign = 1`, это означает, что строка является состоянием объекта. Назовём её строкой состояния.
- Если `sign = -1`, это означает отмену состояния объекта с теми же атрибутами. Назовём её строкой отмены состояния.

### Работа с состояниями

Управление логикой выставления нужных значений `sign` и `version` возлагается на клиента, которым обычно выступает backend-приложение. Backend должен помнить состояние объекта, чтобы иметь возможность отменить его. Строка отмены состояния должна содержать идентичные поля первичного ключа и версии и противоположное значение `sign`.

Существует типичный алгоритм работы с движком VersionedCollapsingMergeTree для обновления данных, он выглядит так:

- вставка новой строки, `sign = 1`, `ver = 1`;
- обновление вставленной строки:
  - удаление старой строки с помощью вставки с тем же ключом, `sign = -1`, `ver = 1`;
  - вставка новой строки с тем же ключом, `sign = 1`, `ver = 2`.

В этом примере новая вставка будет выглядеть так:

```sql
INSERT INTO vcollapsing_mt SELECT 1, 'state_2', 1, 2;
SELECT * FROM vcollapsing_mt FINAL;
```

## Семейство движков \*Log

Движки семейства \*Log предназначены для сценариев, где требуется быстро записывать небольшие объёмы данных (до миллиона строк) в большое количество таблиц, а затем массово читать эти записи. Они идеально подходят для временных таблиц, тестовых данных или хранения промежуточных результатов.

Однако, в отличие от MergeTree, таблицы Log не поддерживают операции `UPDATE` и `DELETE` - изменить или удалить уже записанные данные невозможно. Также движки Log не поддерживают индексы, поэтому поиск по таким таблицам менее эффективен при больших объёмах данных. Основное преимущество - простота и высокая скорость вставки и чтения для небольших таблиц.

### Основные свойства \*Log-таблиц

При записи данных в \*Log-таблицы новые данные добавляются в конец файла. Каждый столбец хранится в отдельном файле. Такие таблицы могут хранить данные в распределённых файловых системах, таких как HDFS или S3. Для обеспечения конкурентного доступа к данным используются блокировки.

Во время выполнения запроса `INSERT` таблица блокируется, что может привести к тому, что другие запросы на чтение и запись будут ожидать снятия блокировки. Если в данный момент нет активных запросов на запись, то можно выполнять любое количество параллельных запросов на чтение.

### Ограничения семейства \*Log

Семейство \*Log имеет следующие ограничения:

- **Отсутствие индексов:** запросы `SELECT` неэффективны для выборки диапазонов данных. Движки \*Log подходят для выборки всех записей сразу.
- **Невозможность модификации данных:** операции `UPDATE` и `DELETE` не поддерживаются.
- **Отсутствие атомарности записи:** в случае прерывания операции записи (например, из-за аварийного завершения работы сервера) таблица может содержать повреждённые данные.

### Разновидности Log-движков

Семейство Log включает три движка:

- TinyLog
- Log
- StripeLog

| ENGINE    | Parallel read | Колонночное хранение | Низкое использование дескрипторов |
| --------- | ------------- | -------------------- | --------------------------------- |
| StripeLog | +             | -                    | +                                 |
| Log       | +             | +                    | -                                 |
| TinyLog   | -             | +                    | -                                 |

Синтаксис создания \*Log-таблиц предельно простой и состоит из перечисления полей и указания типа движка StripeLog, Log или TinyLog:

```sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    column1_name [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],
    ...
) ENGINE = [ StripeLog | Log | TinyLog ]
```

## Движок TinyLog

Свойства движка TinyLog:

- самый простой в семействе и является менее функциональным и эффективным по сравнению с остальными движками;
- не поддерживает параллельное чтение данных в несколько потоков, поэтому читает данные медленнее, чем другие движки семейства;
- хранит каждый столбец в отдельном файле.

Движок TinyLog можно использовать в простых сценариях с низкой нагрузкой.

## Движок Log

Свойства движка Log:

- в отличие от TinyLog, вместе с файлами столбцов хранит небольшой файл засечек, это обеспечивает многопоточное чтение;
- поддерживает параллельное чтение — при чтении данных ClickHouse использует множество потоков, каждый поток обрабатывает отдельный блок данных;
- сохраняет каждый столбец таблицы в отдельном файле.

Движок Log подходит для временных данных, таблиц write-once и тестовых и демонстрационных целей.

## Движок StripeLog

Свойства движка StripeLog:

- хранит все данные в одном файле и использует меньше дескрипторов в операционной системе;
- поддерживает параллельное чтение.

Движок StripeLog используется в тех же случаях, что и Log. Но его стоит выбирать, когда объём занимаемого места важнее, чем скорость чтения

> [!TIP] Замечание
> Если нужно хранить логи объёмом более миллиона строк или персистентно, использовать Log неэффективно. Для такой задачи лучше подойдёт MergeTree.

## Движок EmbeddedRocksDB

ClickHouse включает встроенный движок EmbeddedRocksDB, который предназначен для хранения и обработки данных в формате key-value. Этот движок основан на RocksDB - высокопроизводительной базе данных, являющейся форком Google LevelDB. RocksDB поддерживает такие возможности, как транзакционность, снапшоты (снимки состояния базы), фильтры Блума для ускорения поиска, а также `TTL` (время жизни) для ключей, что позволяет автоматически удалять устаревшие данные.

На данный момент движок EmbeddedRocksDB в ClickHouse поддерживает операции чтения (`SELECT`) и вставки данных (`INSERT`). Однако операции удаления (`DELETE`) и обновления (`UPDATE`) пока не реализованы.

Таблицы с движком EmbeddedRocksDB часто используются для хранения полуструктурированных данных, таких как пользовательские параметры, настройки или метаданные.

Движок RocksDB широко применяется во многих популярных СУБД, включая Cassandra®, MongoDB® и MySQL®, поэтому если вы работали с этими системами, интерфейс для взаимодействия с EmbeddedRocksDB может показаться вам знакомым.

### Особенности движка EmbeddedRocksDB

- **Собственный формат хранения**: В отличие от колоночных таблиц ClickHouse, таблицы на движке EmbeddedRocksDB хранят данные не по столбцам, а в собственном формате RocksDB, в основе которого лежит структура данных LSM-дерево.

- **Ограничения первичного ключа**: Таблицы EmbeddedRocksDB поддерживают только один столбец в первичном ключе. При этом указание первичного ключа является обязательным.

- **Оптимизация запросов**: Запросы с фильтрацией на равенство по ключу или с использованием оператора IN (вхождение в множество) специально оптимизированы для эффективного поиска по нескольким ключам в RocksDB.

- **Поддерживаемые операции**: Движок поддерживает операции SELECT и INSERT, но не поддерживает UPDATE и DELETE.

- **Хранение данных**: Обеспечивает постоянное хранение данных на диске, что гарантирует их сохранность между перезапусками сервера.

Синтаксис создания таблицы:

```sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    pk_name [type1],
    column1_name [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],
    ...
) ENGINE = EmbeddedRocksDB
PRIMARY KEY(pk_name)
```

## Движок URL

Движок URL позволяет работать с данными, расположенными на удалённом сервере, не сохраняя их локально в ClickHouse. Запросы к таблице с этим движком транслируются в HTTP-запросы: операции `SELECT` преобразуются в `GET`-запросы, а `INSERT` - в `POST`-запросы.

При этом модификация данных (`DELETE`, `UPDATE`) не поддерживается, так как движок URL не хранит данные локально и лишь выступает в роли прокси к удалённому источнику.

### Особенности движка URL

- Поддерживает многопоточные операции чтения и записи.
- Не хранит данные локально, обращаясь напрямую к удалённому источнику.
- Не поддерживает изменение данных через команды `ALTER`.
- Не поддерживает семплирование данных.
- Не поддерживает индексы и репликацию.

Синтаксис создания таблицы:

```sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    column1_name [type1] [DEFAULT|ALIAS expr1],
    ...
) ENGINE = URL('http://127.0.0.1:12345/', [CSV | TabSeparated | JSON | ... ])
```

## Движок File

Движок File позволяет взаимодействовать с файлами, аналогично движку URL. При создании таблицы с этим движком, в каталоге базы данных создаётся одноимённый каталог на диске.

### Преимущества использования движка File:

- Выгрузка данных в файл.
- Преобразование данных из одного формата в другой.

### Свойства движка File:

- Многопоточные запись и чтение сериализуются и выполняются последовательно.
- При первой вставке в таблицу создается файл, если он еще не существовал.
- Не поддерживаются изменения данных с помощью ALTER.
- Не поддерживается семплирование.
- Не поддерживаются индексы и репликация.

Синтаксис создания таблицы:

```sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    column1_name [type1] [DEFAULT|ALIAS expr1],
    ...
) ENGINE = File([CSV | TabSeparated | JSON | ... ])
```

## Движок Buffer

Движок Buffer предназначен для временного накопления данных в оперативной памяти перед их записью в основную таблицу-приёмник на диске. Он накапливает вставляемые данные в ОЗУ и при достижении определённых пороговых значений автоматически сбрасывает их в приёмник. При этом, если сервер базы данных перезапускается, данные из буфера не теряются - они сохраняются на диске и будут записаны в основную таблицу при следующем запуске. Такой механизм позволяет повысить производительность массовых вставок, сглаживая нагрузку на диск.

Для движка Buffer доступны операции `SELECT` и `INSERT`. Операции удаления и обновления не поддерживаются.

Этот движок рекомендуется использовать, если необходимо ускорить запись данных и быстро возвращать управление приложению.

Для движков семейства MergeTree оптимальна вставка данных батчами - то есть создание части данных при каждой вставке. С помощью Buffer можно аккумулировать несколько одиночных операций INSERT в один батч.

Для повышения производительности вставки рекомендуется использовать батчи размером от 10 строк и более.

Синтаксис создания таблицы:

```sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    column1_name [type1] [DEFAULT|ALIAS expr1],
    ...
) ENGINE = Buffer(database, target_table,
                  num_layers, min_time, max_time, min_rows,
                  max_rows, min_bytes, max_bytes
);
```

- `database` — имя базы данных.
- `table` — таблица, в которую сбрасываются данные.
- `num_layers` — уровень параллелизма. Физически таблица будет представлена в виде `num_layers` независимых буферов. Рекомендуемое значение — `16`.

Данные сбрасываются из буфера и записываются в таблицу назначения, если выполнены все min-условия или хотя бы одно max-условие.

- `min_time`, `max_time` — условие времени в секундах от момента первой записи в буфер.
- `min_rows`, `max_rows` — условие на количество строк в буфере.
- `min_bytes`, `max_bytes` — условие на количество байт в буфере.

### Асинхронная вставка в движке Buffer

Начиная с версии 21.11, для подключений по HTTP в ClickHouse появилась поддержка асинхронной вставки. Это позволяет достигать скорости порядка 15 000 отдельных вставок в секунду.

В режиме асинхронной вставки данные сначала накапливаются в буфере, а затем в фоновом режиме формируются батчи, которые вставляются в таблицу целиком. Такой подход позволяет существенно ускорить обработку большого количества одиночных операций вставки.

Этот режим настраивается параметрами конфигурации:

- `async_insert = 1` - включает асинхронный режим вставки (по умолчанию 0).
- `async_insert_threads` - определяет количество потоков для фоновой обработки и вставки данных (по умолчанию 16).
- `wait_for_async_insert = 0` - клиент не ждёт завершения сброса данных в таблицу, запрос завершается практически мгновенно. Если установить `wait_for_async_insert = 1`, клиент будет ожидать, пока данные не будут записаны в таблицу.
- `wait_for_async_insert_timeout` - задаёт время ожидания (в секундах) для обработки асинхронной вставки. Значение 0 отключает ожидание.

Асинхронная вставка позволяет эффективно агрегировать множество мелких вставок в крупные батчи, что значительно увеличивает скорость записи данных.

## Движок Memory

Движок Memory предназначен для работы с данными, которые не требуют постоянного хранения и могут быть утрачены без критических последствий, но при этом нуждаются в быстром доступе для чтения. Он хранит все данные исключительно в оперативной памяти, что обеспечивает очень высокую скорость чтения и записи. Он поддерживает операции `SELECT`, `INSERT`, `UPDATE` и `DELETE`, позволяя модифицировать и удалять данные.

Однако при перезапуске сервера все данные в таблицах с движком Memory теряются, так как они не сохраняются на диск. Кроме того, данный движок не поддерживает индексы, что ограничивает возможности оптимизации запросов.

При указании нижней и верхней границ размера таблицы, она может функционировать как кольцевой буфер: когда объём вставляемых данных превышает заданную верхнюю границу, старые записи автоматически удаляются.

### Свойства движка Memory

- Эффективен для работы с датасетами объёмом до 100 миллионов строк.
- Поддерживает параллельное чтение данных.
- Операции чтения и записи не блокируют друг друга.
- Данные хранятся без сжатия.
- Не поддерживает использование индексов.

Синтаксис создания таблицы:

```sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    column1_name [type1] [DEFAULT|ALIAS expr1],
    ...
) ENGINE = Memory [SETTINGS ...]
```

Раздел `SETTINGS` может содержать следующие необязательные параметры:

- `min_bytes_to_keep` — минимальный размер в байтах.
- `max_bytes_to_keep` — максимальный размер в байтах.
- `min_rows_to_keep` — минимальный размер в строках.
- `max_rows_to_keep` — максимальный размер в строках.

Значения по умолчанию — `0`. При указании минимального размера также требуется указать максимальный.

## Движок Set

Движок Set используется для хранения набора значений, которые применяются в правой части оператора `IN` в SQL-запросах. Прямое выполнение `SELECT` из такой таблицы невозможно - она служит исключительно для подстановки значений в условия фильтрации. Движок реализует структуру данных «множество», которая всегда находится в оперативной памяти. Он предназначен для хранения набора неизменяемых данных, к которым требуется быстрый постоянный доступ.

В таблицу Set можно записывать данные с помощью команды `INSERT`. Персистентность данных (сохранение на диск) задаётся специальной опцией при создании таблицы.

Обычные запросы `SELECT` к таблице Set недоступны. В такие таблицы можно загружать данные для последующего использования в условиях отбора с оператором IN.

### Свойства Set-таблиц

- Таблица не поддерживает прямой `SELECT`.
- Возможны дубликаты записей.
- Все данные хранятся в оперативной памяти.
- Существует опция `persistent для` хранения данных на диске.

Персистентность (сохранение данных на диск) настраивается через одноимённую опцию при создании таблицы.

Синтаксис создания таблицы:

```sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    column1_name [type1] [DEFAULT|ALIAS expr1],
    ...
) ENGINE = Set
SETTINGS persistent = [1 | 0];
```

### Работа с движком Set

Создайте таблицы MergeTree и Set и сделайте вставки:

```sql
CREATE TABLE set_tbl (val UInt32) ENGINE = Set;

CREATE TABLE mtree_tbl
(
    id UInt32,
    val UInt32
)
ENGINE = MergeTree
ORDER BY (id);

INSERT INTO set_tbl SELECT number from numbers(30000);
INSERT INTO mtree_tbl SELECT number, (number + 1) * 10 from numbers(300000000);
```

Используйте таблицу Set в выражении `IN` и посмотрите на результат:

```sql
SELECT count(*) FROM mtree_tbl WHERE val in set_tbl;
```

## Движок Join

Движок Join предназначен для предварительной подготовки данных, которые будут использоваться в операциях соединения (`JOIN`) в запросах ClickHouse. В таблицах с этим движком данные полностью загружаются и всегда доступны для быстрого соединения и фильтрации. Движок поддерживает операции чтения (`SELECT`), вставки (`INSERT`) и удаления (`DELETE`), но не позволяет обновлять (`UPDATE`) уже существующие записи. Это делает его удобным для хранения справочных наборов данных, которые часто используются в `JOIN`-операциях.

Этот движок особенно полезен, когда для аналитических задач требуется объединить основную таблицу с небольшими справочниками - например, для подстановки ФИО сотрудников или названия департамента.

### Свойства движка Join

- Таблица используется в правой части секции `JOIN` или в функции `joinGet`.
- Все данные всегда находятся в оперативной памяти.
- Существует опция `persistent` для хранения данных на диске.
- Поддерживаются `DELETE`-мутации.
- Не поддерживается использование в `GLOBAL JOIN`.
- Семплирование не поддерживается.
- Индексы и репликация не поддерживаются.

Синтаксис создания таблицы:

```sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    fld [type1] [DEFAULT|MATERIALIZED|ALIAS expr1] [TTL expr1],
    ...
) ENGINE = Join(
    [ANY | ALL],        -- строгость соединения
    [INNER | LEFT | ...],    -- тип соединения
    fld[, fld2, ...]     -- ключевые столбцы секции USING
)
SETTINGS
   persistent = [1 | 0],
   join_use_nulls = [1 | 0],
   max_rows_in_join = 0,
   max_bytes_in_join = 0,
   join_overflow_mode = [THROW | BREAK],
   join_any_take_last_row = [1 | 0];
```

### Параметры и настройка движка Join

Движок Join в ClickHouse настраивается с помощью трёх основных параметров:

**Строгость соединения** (`ANY`, `ALL`):

- Если таблица создана со строгостью `ANY`, при вставке дублирующиеся ключи игнорируются, и сохраняется только одна строка для каждого ключа.
- Если указано `ALL`, в таблицу добавляются все строки, даже с одинаковыми ключами.

**Тип соединения** (`INNER`, `LEFT` и др.):

- Определяет, какой тип JOIN будет поддерживаться этой таблицей. Если попытаться выполнить, например, `LEFT JOIN` к таблице, созданной с типом `INNER`, возникнет исключение.

**Ключевые столбцы**:

- Указываются при создании таблицы и используются для соединения данных.

Эти параметры определяют, как таблица Join будет применяться в SQL-запросах и какие типы соединений поддерживаются.

### Вспомогательные параметры Join-таблицы

- **persistent** - включает хранение данных на диске.
- **join_use_nulls = [1 | 0]** - определяет, будут ли пустые ячейки заполняться `NULL` или дефолтными значениями при соединении.
- **max_rows_in_join** - ограничение на количество строк в хеш-таблице для соединения (по умолчанию 0 - не ограничено).
- **max_bytes_in_join** - ограничение на объём памяти (в байтах) для хеш-таблицы (по умолчанию 0 - не ограничено).
- **join_overflow_mode** - действие при переполнении лимита строк или памяти:
  - `THROW` (по умолчанию) - выбрасывает исключение и завершает запрос.
  - `BREAK` - завершает операцию соединения без ошибки.
- **join_any_take_last_row** - определяет, какую строку присоединять при совпадении ключа:
  - `0` - первую найденную в правой таблице,
  - `1` - последнюю найденную в

### Пример создание таблицы с типом Join

Создайте таблицу с Join для типов соединения `INNER` со строгостью `ANY` и проверьте, как отрабатывают корректные и некорректные выборки.

```sql
DROP TABLE IF EXISTS mtree_tbl;

CREATE TABLE mtree_tbl
(
    id UInt32,
    val UInt32
)
ENGINE = MergeTree
ORDER BY (id);

INSERT INTO mtree_tbl SELECT number, (number + 1) * 10 FROM numbers(10);

CREATE TABLE join_tbl
ENGINE = Join(ANY, INNER , id) as SELECT id, val * 10 as val
FROM mtree_tbl where id >= 5;
```

Проверьте данные в таблице `join_tbl` и сделайте соединение корректным:

```sql
SELECT * FROM join_tbl ORDER BY id

SELECT *
FROM mtree_tbl AS mt
ANY INNER JOIN join_tbl jt USING(id);
```

Дополнительно попробуйте другой тип соединения:

```sql
SELECT *
FROM mtree_tbl AS mt
ANY LEFT JOIN join_tbl jt USING(id);
```

## Движок S3

Движок S3 обеспечивает интеграцию с веб-службой Simple Storage Service (S3), предоставляющей возможность хранения и получения любых объёмов данных.

Использование S3 позволяет существенно сэкономить на хранении данных по сравнению с другими движками.

### Свойства движка S3

- Поддерживает параллельное чтение и запись данных.
- Не поддерживает операции `ALTER` и мутации (`UPDATE`, `DELETE`).
- Не поддерживает семплирование.
- Не поддерживает индексы и репликацию.

Синтаксис создания таблицы:

```sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    fld [type1] [DEFAULT|ALIAS expr1],
    ...
) ENGINE = S3(path, [aws_access_key_id, aws_secret_access_key,] format, [compression]);
```

Обязательные параметры:

- `path` — URL-адрес бакета с указанием пути к файлу. Для обращения к нескольким файлам предусмотрены подстановочные знаки: `*`, `?`, `{abc,def}`.
- `format` — формат файла, например CSV, JSON, TSV.

Необязательные параметры:

- `aws_access_key_id`, `aws_secret_access_key` — данные пользователя учётной записи AWS могут быть заданы в файле конфигурации.
- `compression` — тип сжатия. Возможные значения: `none`, `gzip/gz`, `brotli/br`, `xz/LZMA`, `zstd/zst`.

Таблицы на движке S3 имеют виртуальные колонки: `_path` и `_file`.

## Движок PostgreSQL

Движок PostgreSQL предоставляет возможность работать с внешними таблицами, находящимися в базе данных PostgreSQL, напрямую из ClickHouse. С помощью этого движка можно выполнять операции чтения (`SELECT`) и вставки (`INSERT`) данных, используя ClickHouse как интерфейс доступа к внешним данным. Данные физически хранятся во внешней системе, а не в ClickHouse. Это позволяет интегрировать ClickHouse с PostgreSQL и использовать возможности обеих систем в рамках одной аналитической задачи.

## Движок Kafka

Движок Kafka предназначен для интеграции с потоковыми данными из Apache Kafka. Он не хранит данные самостоятельно, а используется для подписки на потоки данных (consumer) и публикации данных (producer) в Kafka-топики. Такой подход позволяет ClickHouse эффективно обрабатывать и анализировать потоковые данные в реальном времени, используя возможности Kafka для обмена сообщениями между системами.
