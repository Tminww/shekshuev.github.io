# Структура базы данных

## Основные движки таблиц в ClickHouse

ClickHouse предлагает разнообразные движки таблиц, каждый из которых оптимизирован для определенных сценариев использования. Движок таблицы определяет ключевые аспекты работы с данными: способ хранения, поддерживаемые типы запросов, возможности индексации, многопоточность и репликацию.

| ENGINE          | SELECT    | INSERT | DELETE | UPDATE | persistent | indexes |
| --------------- | --------- | ------ | ------ | ------ | ---------- | ------- |
| \*MergeTree     | +         | +      | +      | +      | +          | +       |
| \*Log           | +         | +      | +      | -      | +          | -       |
| EmbeddedRocksDB | +         | +      | +      | -      | +          | -       |
| URL             | +         | -/+    | -      | -      | external   | -       |
| Buffer          | +         | +      | -      | -      | +          | -       |
| Memory          | +         | +      | +      | +      | -          | -       |
| Set             | (only IN) | -      | -      | -      | +          | -       |
| Join            | +         | -      | -      | -      | +          | -       |
| PostgreSQL      | +         | +      | -      | -      | external   | -       |
| Kafka           | +         | -      | -      | -      | external   | -       |

Примечания:

- `+` - поддерживается

- `-` - не поддерживается

- `- / +` - частичная поддержка или зависит от конфигурации

- `external` - данные хранятся во внешней системе

- `(only IN)` - поддерживается только операция IN

- `persistent` - "постоянное хранение" (указывает, сохраняются ли данные на диск или во внешней системе)

- `indexes` - "индексы" (указывает, поддерживает ли движок индексацию данных)

## Семейство движков \*MergeTree

Движки семейства \*MergeTree - это основа ClickHouse и наиболее часто используемый тип таблиц в этой СУБД. Они предназначены для хранения больших объёмов данных на диске в сжатом виде и поддерживают полный набор операций DML: `SELECT`, `INSERT`, `DELETE`, `UPDATE`. Благодаря этому можно не только читать и добавлять данные, но и выполнять их удаление и обновление.

Ключевая особенность MergeTree - поддержка индексов, в том числе уникальных для ClickHouse индексов пропуска данных (разреженных индексов). Эти индексы позволяют эффективно фильтровать данные и ускоряют выполнение аналитических запросов на больших таблицах. Таблицы MergeTree могут быть оптимизированы с помощью партиционирования и сортировки по ключу, что дополнительно увеличивает производительность при работе с большими объёмами информации.

## Разновидности движков семейства MergeTree

Семейство MergeTree в ClickHouse включает несколько разновидностей движков, каждая из которых обладает своей спецификой и дополнительными возможностями.

### Базовый MergeTree

Движок MergeTree является локальной таблицей, которая хранит данные на диске в исходном виде без каких-либо дополнительных преобразований. Он обеспечивает эффективное хранение и быстрый доступ к данным, поддерживает операции вставки, чтения, удаления и обновления, а также использование разреженных индексов для ускорения запросов.

### Расширенные движки на базе MergeTree

Помимо базового MergeTree, существуют движки, которые наследуют его архитектуру хранения данных, но добавляют специальные механизмы, работающие во время фонового процесса слияния данных (merge). Эти механизмы позволяют реализовать дополнительные функции, такие как агрегация и дедупликация.

- **AggregatingMergeTree** и **SummingMergeTree** - используются для хранения агрегированных данных, например, суммарных значений за разные периоды. Они позволяют автоматически агрегировать данные при слиянии частей таблицы, что упрощает и ускоряет аналитические вычисления.

- **ReplacingMergeTree** - предназначен для автоматического удаления дубликатов записей, оставляя только последнюю версию данных по ключу. Это полезно, когда данные могут обновляться путём вставки новых версий.

- **CollapsingMergeTree (с параметром sign)** - реализует механизм «свёртывания» строк с противоположными значениями sign, что позволяет эффективно удалять отменённые записи и поддерживать консистентность данных.

- **VersionedCollapsingMergeTree** - расширяет возможности CollapsingMergeTree, добавляя поддержку версионирования записей для более точного контроля обновлений и удаления.

Рассмотрим их подробнее.

## Движок SummingMergeTree

Движок SummingMergeTree предназначен для хранения данных с автоматической агрегацией по сумме значений в определённых числовых столбцах. Основной принцип работы этого движка заключается в том, что при слиянии частей таблицы все строки, имеющие одинаковый ключ сортировки (первичный ключ), объединяются в одну запись. При этом для указанных в параметрах движка числовых столбцов происходит суммирование значений.

В отличие от AggregatingMergeTree, который поддерживает широкий набор агрегатных функций, SummingMergeTree умеет работать только с операцией суммирования.

Для столбцов, входящих в ключ сортировки, значения остаются без изменений, так как они определяют уникальность записи. Для остальных столбцов, не участвующих в суммировании и не входящих в ключ, выбирается одно из значений, случайным образом взятое из объединяемых строк.

Если в таблице используются вложенные структуры (например, вложенные массивы или объекты), суммирование происходит по соответствующим полям внутри этих структур.

Для получения окончательных агрегированных данных, учитывающих все слияния, можно использовать модификатор `FINAL` в операторе `SELECT`. Это позволяет получить результат, в котором все промежуточные части данных, ещё не объединённые в процессе слияния, будут учтены.

Выполните код, чтобы создать таблицу и добавить в неё данные.

```sql
CREATE TABLE summing_mt
(
    id UInt32,
    val UInt32,
    example UInt32,  -- столбец, не входящий в ключ сортировки и параметры движка
)
ENGINE = SummingMergeTree(val) -- сумма будет считаться по полю val, так как оно указано в качестве параметра движка
ORDER BY (id); -- записи по этому ключу будут группироваться

INSERT INTO summing_mt SELECT 1, (number + 1) * 10, (number + 1) * 100 from numbers(3);
INSERT INTO summing_mt SELECT 1, 10, 100;
```

Посмотрите на выборку:

```sql
SELECT * FROM summing_mt;
```

Здесь вы видите два куска, для которых слияние ещё не запустилось.

Теперь обратите внимание на вторую выборку:

```sql
SELECT * FROM summing_mt FINAL;
```

Модификатор `FINAL` выдаст данные, как будто слияние уже произошло.

Альтернативным способом получить актуальные данные является запуск команды `OPTIMIZE` по целевой таблице или по указанной партиции.

```sql
OPTIMIZE TABLE summing_mt FINAL;
SELECT * FROM summing_mt;
```

В результате вы увидите, что после `OPTIMIZE` данные просуммировались.

Для подготовки данных, на основе которых будут строиться отчёты, целесообразно использовать движок SummingMergeTree вместе с обычной MergeTree-таблицей. Такая связка позволяет эффективно агрегировать данные по суммам и при этом сохранять исходные записи.

При чтении данных из нескольких партиций или при выполнении агрегаций важно использовать модификатор `FINAL`. Без него записи из разных партиций не будут объединяться и заменяться корректно, что может привести к некорректным результатам. Это правило действует для всех таблиц семейства MergeTree.

## Движок AggregatingMergeTree

Движок AggregatingMergeTree представляет собой таблицу, которая группирует записи с одинаковым ключом сортировки и применяет к полям агрегатные функции. В отличие от SummingMergeTree, который поддерживает только операцию суммирования, AggregatingMergeTree позволяет использовать широкий набор агрегатов - подсчёт уникальных значений, вычисление среднего, перцентилей и другие.

При создании таблицы с движком AggregatingMergeTree необходимо явно указать агрегатные функции для соответствующих столбцов, чтобы ClickHouse знал, как агрегировать данные при слиянии.

Рассмотрим пример:

```sql
CREATE TABLE agg_mt
(
    id UInt32,
    val SimpleAggregateFunction(max, UInt32) -- агрегатная функция max
)
ENGINE = AggregatingMergeTree
ORDER BY (id);

INSERT INTO agg_mt SELECT 1, (number + 1) * 10 from numbers(3); -- 10, 20, 30

SELECT * FROM agg_mt

INSERT INTO agg_mt SELECT 1, 50;    -- вставка данных в новый кусок

SELECT * FROM agg_mt

```

Последний `SELECT` нам выдал 2 строки, потому что данные вставились в разные куски, а агрегация срабатывает для данных в одному куске. Нужно, чтобы прошло слияние и данные оказались в одном куске. С инструкцией `FINAL` можно увидеть результат, будто слияние уже прошло, вот так:

```sql
SELECT * FROM agg_mt FINAL
```

Получить нужный результат без использования `FINAL` и фоновых слияний `OPTIMIZE` можно, применяя агрегатную функцию в запросе и группируя записи по ключу:

```sql
SELECT id, max(val) as val
FROM agg_mt
GROUP BY id;
```

> [!CAUTION] Внимание
> `FINAL` работает примерно в полтора-два раза медленнее, чем явное указание группировки.

```sql
OPTIMIZE TABLE agg_mt; -- выполнение слияния с помощью OPTIMIZE

SELECT * FROM agg_mt
```

В результате - одна строка, как в запросе с `GROUP BY`.

```sql
INSERT INTO agg_mt SELECT 2, 150;  -- вставка новой записи с другим id

OPTIMIZE TABLE agg_mt;  -- выполнение слияния

SELECT * FROM agg_mt
```

Здесь на выходе получается две строки, так как `ORDER BY (id)`, а у нас id разные.

> [!TIP] Замечание
> Следующие три движка используются в ситуациях, когда исходный MergeTree не подходит из-за низкой производительности, а именно — когда нужно совершать много операций обновления.

## Движок ReplacingMergeTree

Движок ReplacingMergeTree предназначен для удаления дублирующихся записей с одинаковым значением ключа сортировки. В процессе фонового слияния данных (merge) все дубликаты по ключу заменяются на одну запись - последнюю по времени вставки.

Важно понимать, что удаление дубликатов происходит асинхронно и в неопределённый момент времени, поэтому в выборках без использования модификатора `FINAL` могут встречаться дубликаты.

Кроме того, ReplacingMergeTree поддерживает необязательный параметр `ver` - столбец с номером версии. При указании этого параметра движок сохраняет запись с максимальным значением версии для каждого ключа сортировки, что позволяет более точно контролировать, какая версия данных останется после дедупликации.

### Ключевые особенности ReplacingMergeTree:

- Удаляет дубликаты по ключу сортировки при слиянии данных.
- Дедупликация происходит в фоновом режиме и не гарантируется при чтении без `FINAL`.
- Поддерживает параметр версии для выбора актуальной записи.
- Подходит для хранения данных без дубликатов, когда возможна задержка в их удалении.

Чтобы посмотреть на практике, как работает ReplacingMergeTree, создайте таблицу с помощью кода:

```sql
CREATE TABLE replacing_mt
(
    id UInt32,
    val UInt32
)
ENGINE = ReplacingMergeTree
ORDER BY (id);
```

Вставим искусственные данные. Для этого воспользуемся функцией `numbers`

```sql
SELECT 1, (number + 1) * 10 FROM numbers(3);
```

Запрос выполняет выборку из виртуальной таблицы, которую создаёт функция `numbers(3)`. Эта функция генерирует последовательность из трёх чисел: `0`, `1` и `2`. В результате для каждой строки формируется два столбца: первый всегда равен `1`, а второй вычисляется как `(number + 1) * 10`. То есть для каждой строки к текущему значению `number` прибавляется единица, а затем результат умножается на `10`.

Заполним этими данными таблицу:

```sql
INSERT INTO replacing_mt SELECT 1, (number + 1) * 10 from numbers(3);
SELECT * FROM replacing_mt;
```

Обратите внимание, вы вставляли три записи, а вставилась в итоге одна. Это произошло потому, что вставка `INSERT` шла в одном батче и попала в один кусок, то есть replacing отработал сразу. У всех записей `id=1`, поэтому осталась только последняя.

Теперь посмотрите на код ниже:

```sql
INSERT INTO replacing_mt SELECT 1, 3;
SELECT * FROM replacing_mt
SELECT * FROM replacing_mt FINAL
```

Новая вставка произошла в новый кусок. С использованием `FINAL` мы видим результирующий вариант. Асинхронно в фоне запускается слияние, или вы можете форсированно запустить его с помощью `OPTIMIZE`.

Движок ReplacingMergeTree может быть параметризован полем, указывающим на номер строки `ENGINE = ReplacingMergeTree(version_fld)`. Кроме целочисленных типов поля используются для `Date` или `DateTime`. Когда запускается слияние, остаётся строка с максимальным номером `version`.

Рассмотрим пример кода с версионированием:

```sql
CREATE TABLE replacing_mt_v
(
    id UInt32,
    val UInt32,
    version Int32 -- в рамках id останется одна строка с максимальным значением поля version
)
ENGINE = ReplacingMergeTree(version)
ORDER BY (id);
```

Обратите внимание на поле `version` — в рамках id останется одна строка с максимальным значением поля `version`.

## Движок CollapsingMergeTree

Движок CollapsingMergeTree используется для асинхронного удаления пар строк, которые имеют одинаковые значения по ключу сортировки, но противоположные значения в специальном поле `Sign`. Название этого поля можно выбрать любое, главное - указать его при создании таблицы как параметр движка.

Принцип работы следующий:

- Если у двух строк совпадают все значения по ключу сортировки, а в поле `Sign` у одной строки стоит `1` (означает "активная запись"), а у другой - `-1` (означает "отменённая запись" или "удаление"), то такая пара строк будет автоматически "свёрнута" (удалена) в процессе фонового слияния данных.
- CollapsingMergeTree позволяет реализовать логику отмены или удаления записей без явного удаления строк, что удобно для аналитических сценариев.

Рассмотрим пример:

```sql
CREATE TABLE UAct
(
    UserID UInt64,
    PageViews UInt8,
    Duration UInt8,
    Sign Int8
)
ENGINE = CollapsingMergeTree(Sign)
ORDER BY UserID
```

В этом примере приложение фиксирует количество просмотров. Используйте код для эмуляции действий приложения:

```sql
INSERT INTO UAct VALUES (4324182021466249494, 5, 146, 1)
```

Теперь представьте, что пользователь посмотрел страницу ещё раз, и вам нужно зафиксировать новую цифру, то есть произвести `UPDATE`. Приложение должно отправить в таком случае две записи для вставки:

```sql
INSERT INTO UAct
VALUES (4324182021466249494, 5, 146, -1),(4324182021466249494, 6, 185, 1)
```

Строка с `Sign = -1` свернёт старую версию данных. А строка с `Sign = 1` добавит новую. Теперь проверьте выборку с `FINAL` и без него:

```sql
SELECT * FROM UAct;
SELECT * FROM UAct FINAL;
```

Обратите внимание, что после слияния остаётся одна версия записи.

## VersionedCollapsingMergeTree

VersionedCollapsingMergeTree реализует логику CollapsingMergeTree, но использует другой алгоритм удаления строк и адаптирован для многопоточной вставки. Это достигается при помощи дополнительного поля `version`. Движок VersionedCollapsingMergeTree удаляет дублирующиеся записи с одинаковым значением ключа сортировки, за исключением поля sign с учётом версии строки. Этот процесс имеет альтернативное название — сворачивание записей.
Когда выполняется процесс слияния, ClickHouse удаляет каждую пару строк, которые имеют один и тот же первичный ключ и версию, но разный `Sign`. Чтобы получить полностью свёрнутые данные из таблицы, необходимо использовать агрегирование или модификатор `FINAL`.

```sql
CREATE TABLE vcollapsing_mt
(
    id UInt32,
    val String,
    sign Int8,
    version UInt8 -- удаляет каждую пару строк, которые имеют один и тот же первичный ключ, версию и разный sign
)
ENGINE = VersionedCollapsingMergeTree(sign, version)
ORDER BY (id);

```

После этого добавьте в таблицу две записи с одинаковым `id`, равным единице. Строки будут различаться значением поля `sign`: у первой строки `1`, у второй строки `-1`.
Это означает удаление предыдущей строки в рамках `id`, у которой совпадает значение поля `version`.

```sql
INSERT INTO vcollapsing_mt SELECT 1, 'state_1', 1, 1;
INSERT INTO vcollapsing_mt SELECT 1, 'cancel state', -1, 1;
```

Теперь проверьте вставку и результат слияния:

```sql
SELECT * FROM vcollapsing_mt;
SELECT * FROM vcollapsing_mt FINAL
```

На примере видно, что если выполнить выборку из таблицы `vcollapsing_mt FINAL`, то выборка не вернёт записи, потому что тут подразумевается удаление вставленной записи.

Разберём значения поля `sign:

- Если `sign = 1`, это означает, что строка является состоянием объекта. Назовём её строкой состояния.
- Если `sign = -1`, это означает отмену состояния объекта с теми же атрибутами. Назовём её строкой отмены состояния.

### Работа с состояниями

Управление логикой выставления нужных значений `sign` и `version` возлагается на клиента, которым обычно выступает backend-приложение. Backend должен помнить состояние объекта, чтобы иметь возможность отменить его. Строка отмены состояния должна содержать идентичные поля первичного ключа и версии и противоположное значение `sign`.

Существует типичный алгоритм работы с движком VersionedCollapsingMergeTree для обновления данных, он выглядит так:

- вставка новой строки, `sign = 1`, `ver = 1`;
- обновление вставленной строки:
  - удаление старой строки с помощью вставки с тем же ключом, `sign = -1`, `ver = 1`;
  - вставка новой строки с тем же ключом, `sign = 1`, `ver = 2`.

В этом примере новая вставка будет выглядеть так:

```sql
INSERT INTO vcollapsing_mt SELECT 1, 'state_2', 1, 2;
SELECT * FROM vcollapsing_mt FINAL;
```

## Семейство движков \*Log

Движки семейства \*Log предназначены для сценариев, где требуется быстро записывать небольшие объёмы данных (до миллиона строк) в большое количество таблиц, а затем массово читать эти записи. Они идеально подходят для временных таблиц, тестовых данных или хранения промежуточных результатов.

Однако, в отличие от MergeTree, таблицы Log не поддерживают операции `UPDATE` и `DELETE` - изменить или удалить уже записанные данные невозможно. Также движки Log не поддерживают индексы, поэтому поиск по таким таблицам менее эффективен при больших объёмах данных. Основное преимущество - простота и высокая скорость вставки и чтения для небольших таблиц.

### Основные свойства \*Log-таблиц

При записи данных в \*Log-таблицы новые данные добавляются в конец файла. Каждый столбец хранится в отдельном файле. Такие таблицы могут хранить данные в распределённых файловых системах, таких как HDFS или S3. Для обеспечения конкурентного доступа к данным используются блокировки.

Во время выполнения запроса `INSERT` таблица блокируется, что может привести к тому, что другие запросы на чтение и запись будут ожидать снятия блокировки. Если в данный момент нет активных запросов на запись, то можно выполнять любое количество параллельных запросов на чтение.

### Ограничения семейства \*Log

Семейство \*Log имеет следующие ограничения:

- **Отсутствие индексов:** запросы `SELECT` неэффективны для выборки диапазонов данных. Движки \*Log подходят для выборки всех записей сразу.
- **Невозможность модификации данных:** операции `UPDATE` и `DELETE` не поддерживаются.
- **Отсутствие атомарности записи:** в случае прерывания операции записи (например, из-за аварийного завершения работы сервера) таблица может содержать повреждённые данные.

### Разновидности Log-движков

Семейство Log включает три движка:

- TinyLog
- Log
- StripeLog

| ENGINE    | Parallel read | Колонночное хранение | Низкое использование дескрипторов |
| --------- | ------------- | -------------------- | --------------------------------- |
| StripeLog | +             | -                    | +                                 |
| Log       | +             | +                    | -                                 |
| TinyLog   | -             | +                    | -                                 |

Синтаксис создания \*Log-таблиц предельно простой и состоит из перечисления полей и указания типа движка StripeLog, Log или TinyLog:

```sql
CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
(
    column1_name [type1] [DEFAULT|MATERIALIZED|ALIAS expr1],
    ...
) ENGINE = [ StripeLog | Log | TinyLog ]
```

## Движок TinyLog

Свойства движка TinyLog:

- самый простой в семействе и является менее функциональным и эффективным по сравнению с остальными движками;
- не поддерживает параллельное чтение данных в несколько потоков, поэтому читает данные медленнее, чем другие движки семейства;
- хранит каждый столбец в отдельном файле.

Движок TinyLog можно использовать в простых сценариях с низкой нагрузкой.

## Движок Log

Свойства движка Log:

- в отличие от TinyLog, вместе с файлами столбцов хранит небольшой файл засечек, это обеспечивает многопоточное чтение;
- поддерживает параллельное чтение — при чтении данных ClickHouse использует множество потоков, каждый поток обрабатывает отдельный блок данных;
- сохраняет каждый столбец таблицы в отдельном файле.

Движок Log подходит для временных данных, таблиц write-once и тестовых и демонстрационных целей.

## Движок StripeLog

Свойства движка StripeLog:

- хранит все данные в одном файле и использует меньше дескрипторов в операционной системе;
- поддерживает параллельное чтение.

Движок StripeLog используется в тех же случаях, что и Log. Но его стоит выбирать, когда объём занимаемого места важнее, чем скорость чтения

> [!TIP] Замечание
> Если нужно хранить логи объёмом более миллиона строк или персистентно, использовать Log неэффективно. Для такой задачи лучше подойдёт MergeTree.

## Движок EmbeddedRocksDB

ClickHouse включает встроенный движок EmbeddedRocksDB, который предназначен для хранения и обработки данных в формате key-value. Этот движок основан на RocksDB - высокопроизводительной базе данных, являющейся форком Google LevelDB. RocksDB поддерживает такие возможности, как транзакционность, снапшоты (снимки состояния базы), фильтры Блума для ускорения поиска, а также `TTL` (время жизни) для ключей, что позволяет автоматически удалять устаревшие данные.

На данный момент движок EmbeddedRocksDB в ClickHouse поддерживает операции чтения (`SELECT`) и вставки данных (`INSERT`). Однако операции удаления (`DELETE`) и обновления (`UPDATE`) пока не реализованы.

## Движок URL

Движок URL позволяет работать с данными, расположенными на удалённом сервере, не сохраняя их локально в ClickHouse. Запросы к таблице с этим движком транслируются в HTTP-запросы: операции `SELECT` преобразуются в `GET`-запросы, а `INSERT` - в `POST`-запросы.

При этом модификация данных (`DELETE`, `UPDATE`) не поддерживается, так как движок URL не хранит данные локально и лишь выступает в роли прокси к удалённому источнику.

Таким образом, движок URL удобен для интеграции с внешними сервисами и получения данных из них в режиме реального времени, без необходимости их дублирования в ClickHouse.

## Движок Buffer

Движок Buffer предназначен для временного накопления данных в оперативной памяти перед их записью в основную таблицу-приёмник на диске. Он накапливает вставляемые данные в ОЗУ и при достижении определённых пороговых значений автоматически сбрасывает их в приёмник. При этом, если сервер базы данных перезапускается, данные из буфера не теряются - они сохраняются на диске и будут записаны в основную таблицу при следующем запуске. Такой механизм позволяет повысить производительность массовых вставок, сглаживая нагрузку на диск.

Для движка Buffer доступны операции `SELECT` и `INSERT`. Операции удаления и обновления не поддерживаются.

## Движок Memory

Движок Memory хранит все данные исключительно в оперативной памяти, что обеспечивает очень высокую скорость чтения и записи. Он поддерживает операции `SELECT`, `INSERT`, `UPDATE` и `DELETE`, позволяя модифицировать и удалять данные.

Однако при перезапуске сервера все данные в таблицах с движком Memory теряются, так как они не сохраняются на диск. Кроме того, данный движок не поддерживает индексы, что ограничивает возможности оптимизации запросов.

## Движок Set

Движок Set используется для хранения набора значений, которые применяются в правой части оператора `IN` в SQL-запросах. Прямое выполнение `SELECT` из такой таблицы невозможно - она служит исключительно для подстановки значений в условия фильтрации.

В таблицу Set можно записывать данные с помощью команды `INSERT`. Персистентность данных (сохранение на диск) задаётся специальной опцией при создании таблицы.

Таким образом, движок Set удобен для реализации быстрых проверок вхождения значений в заранее определённый набор без необходимости полноценного хранения и обработки данных.

## Движок Join

Движок Join предназначен для предварительной подготовки данных, которые будут использоваться в операциях соединения (`JOIN`) в запросах ClickHouse. В таблицах с этим движком данные полностью загружаются и всегда доступны для быстрого соединения и фильтрации. Движок поддерживает операции чтения (`SELECT`), вставки (`INSERT`) и удаления (`DELETE`), но не позволяет обновлять (`UPDATE`) уже существующие записи. Это делает его удобным для хранения справочных наборов данных, которые часто используются в `JOIN`-операциях.

## Движок PostgreSQL

Движок PostgreSQL предоставляет возможность работать с внешними таблицами, находящимися в базе данных PostgreSQL, напрямую из ClickHouse. С помощью этого движка можно выполнять операции чтения (`SELECT`) и вставки (`INSERT`) данных, используя ClickHouse как интерфейс доступа к внешним данным. Данные физически хранятся во внешней системе, а не в ClickHouse. Это позволяет интегрировать ClickHouse с PostgreSQL и использовать возможности обеих систем в рамках одной аналитической задачи.

## Движок Kafka

Движок Kafka предназначен для интеграции с потоковыми данными из Apache Kafka. Он не хранит данные самостоятельно, а используется для подписки на потоки данных (consumer) и публикации данных (producer) в Kafka-топики. Такой подход позволяет ClickHouse эффективно обрабатывать и анализировать потоковые данные в реальном времени, используя возможности Kafka для обмена сообщениями между системами.
