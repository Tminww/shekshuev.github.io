<script setup>
import Conversation from "../../../../components/Conversation.vue";
import alexey from "../../../assets/databases/heroes/clerk_alexey.png";
import ivan from "../../../assets/databases/heroes/clerk_ivan.png";
import petr from "../../../assets/databases/heroes/petr.png";


</script>

# Простой запрос. Использование выражений в запросе

## Введение

1682 год. В России скончался царь Фёдор III Алексеевич, старший сын царя Алексея Михайловича. Его смерть вызвала серьёзный политический кризис и борьбу за власть между двумя влиятельными родами — Милославскими и Нарышкиными.

Милославские поддерживали старшего брата Фёдора — Ивана Алексеевича, а Нарышкины — младшего, Петра Алексеевича. В Москве вспыхнул Стрелецкий бунт, в ходе которого стрельцы открыто поддержали Ивана, выступая против усиления влияния Петра и Нарышкиных.

В итоге была достигнута политическая компромиссная договорённость: власть была разделена между двумя царями — Иваном V и Петром I, при этом фактически сосредоточилась в руках их сестры Софьи Алексеевны, которая стала регентшей при малолетних царях.

В это время молодой Пётр жил в царской резиденции в селе Преображенском под Москвой. Там он начал формировать свои первые воинские части — Потешные полки, появившиеся примерно в 1683 году. Эти полки стали основой будущих реформ в армии и военной организации России.

Пётр увлекался европейскими военными новшествами и, вместе с друзьями, проводил военные учения, закладывая фундамент военной мощи будущей России.

1686 год. В нашей истории рядом с Петром находятся два дьяка (герои вымышленные).

![Разговор Петра с дьяками](./../../../assets/databases/story/petr_talk_with_clerks.png)

- Дьяк Алексей — опытный государственный служащий, помощник Петра в административных делах.
- Дьяк Иван — молодой помощник Алексея, которому поручают вести учёт и составлять отчёты.
  Они оба работают в царской администрации, где ведётся учёт воинских подразделений и других данных.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Алексей, надобно мне ведомость полков Потешных — кто командует, где стоят, сколь воинов в каждом. Пусть Иван составит полную таблицу',
        photo: petr
    },
    {
        name: 'Алексей',
        position: 'right',
        text: 'Будет исполнено, государь. Иван, приготовь список полков с полной информацией.',
        photo: alexey
    },
    {
        name: 'Иван',
        position: 'left',
        text: 'Господин мой, как выбрать все данные из таблицы?',
        photo: ivan
    }
]"/>

## Немного про SQL

**SQL (Structured Query Language)** — это язык программирования, предназначенный для управления и работы с реляционными базами данных. Он позволяет создавать, изменять и получать данные из таблиц, которые хранят информацию в виде строк и столбцов.

SQL делится на несколько подъязыков:

- **DDL (Data Definition Language)** — команды для создания и изменения структуры базы данных (`CREATE`, `ALTER`, `DROP`).

- **DML (Data Manipulation Language)** — команды для работы с данными: выборка (`SELECT`), вставка (`INSERT`), обновление (`UPDATE`), удаление (`DELETE`, `TRUNCATE`).

- **DCL (Data Control Language)** — управление правами доступа (`GRANT`, `REVOKE`).

- **TCL (Transaction Control Language)** — управление транзакциями (`BEGIN`, `COMMIT`, `ROLLBACK`).

SQL широко используется в бизнесе, науке, веб-разработке, аналитике и многих других областях, где необходима работа с большими объёмами данных.

Преимущества SQL:

- Позволяет работать с большими и сложными наборами данных.

- Универсален и поддерживается большинством СУБД (PostgreSQL, MySQL, Oracle, MS SQL Server и др.).

- Обеспечивает мощные средства для выборки, фильтрации, группировки и анализа данных.

- Является декларативным языком — вы описываете, что хотите получить, а не как это сделать.

Недостатки:

- Требует понимания структур данных и логики запросов.

- Иногда сложные запросы могут быть трудны для оптимизации.

Изучение SQL — важный навык для аналитиков, разработчиков и всех, кто работает с данными.

<Conversation :phrases="[
    {
        name: 'Иван',
        position: 'left',
        text: 'Алексей, как же выбрать все данные из таблицы?',
        photo: ivan
    },
    {
        name: 'Алексей',
        position: 'right',
        text: 'Просто, Иван! Сейчас расскажу',
        photo: alexey
    }
]"/>

В рамках текущего занятия мы будем работать с таблицей, содержащей информацию о Потешных полках — воинских формированиях эпохи Петра I. Эта таблица поможет нам освоить основные приемы выборки данных с помощью SQL.

| id  | name      | surname    | birth_date | location        | soldiers_count | is_historical |
| --- | --------- | ---------- | ---------- | --------------- | -------------- | ------------- |
| 1   | Сергей    | Бухвостов  | 1659-01-01 | Преображенское  | 1200           | true          |
| 2   | Александр | Меншиков   | 1673-11-16 | Семёновское     | 1100           | true          |
| 3   | Патрик    | Гордон     | 1635-03-31 | Измайлово       | 900            | true          |
| 4   | Фёдор     | Матвеевич  | 1661-12-07 | Москва          | 800            | true          |
| 5   | Иван      | Кантемир   | 1668-01-05 | Новгород        | 700            | false         |
| 6   | Иван      | Шереметев  | 1670-07-22 | Санкт-Петербург | 650            | false         |
| 7   | Михаил    | Голицын    | 1675-04-30 | Москва          | 600            | false         |
| 8   | Василий   | Долгорукий | 1662-12-12 | Тула            | 550            | false         |
| 9   | Дмитрий   | Трубецкой  | 1678-05-18 | Ярославль       | 500            | false         |
| 10  | Андрей    | Воронцов   | 1672-10-25 | Санкт-Петербург | 450            | false         |
| 11  | Николай   | Репнин     | 1676-08-14 | Москва          | 400            | false         |
| 12  | Иван      | Романов    | 1669-03-03 | Санкт-Петербург | 380            | false         |
| 13  | Алексей   | Орлов      | 1674-11-21 | Новгород        | 360            | false         |
| 14  | Дмитрий   | Волконский | 1667-06-11 | Тверь           | 340            | false         |
| 15  | Сергей    | Романов    | 1671-02-28 | Москва          | 320            | false         |
| 16  | Пётр      | Козлов     | 1679-09-07 | Санкт-Петербург | 300            | false         |
| 17  | Иван      | Ширинский  | 1673-05-15 | Ярославль       | 280            | false         |
| 18  | Михаил    | Кутузов    | 1670-12-01 | Москва          | 260            | false         |
| 19  | Алексей   | Лопухин    | 1666-07-19 | Новгород        | 240            | false         |
| 20  | Василий   | Трубецкой  | 1677-04-22 | Санкт-Петербург | 220            | false         |

Таблица состоит из 20 строк и следующих столбцов:

- `id` — уникальный идентификатор записи (первичный ключ).

- `name` — имя командира полка.

- `surname` — фамилия командира полка.

- `birth_date` — дата рождения командира в формате ГГГГ-ММ-ДД.

- `location` — место расположения соответствующего Потешного полка.

- `soldiers_count` — численность солдат в полку.

- `is_historical` — признак, указывающий, является ли полк реальным историческим подразделением («Да») или вымышленным для учебных целей («Вымышленный»).

Используя эту таблицу, мы будем практиковаться в составлении SQL-запросов для выборки и преобразования данных. Начнем с базового синтаксиса.

```sql
SELECT <столбцы или *> FROM <таблица>;
```

После ключевого слова `SELECT` нужно указать либо столбцы, либо символ `*`. Например:

```sql
SELECT * FROM poteshnye_polki;
```

Этот запрос выбирает все строки и все столбцы из таблицы. Это удобно, когда нужно быстро получить полную информацию.
Однако при больших таблицах это может привести к избыточному объёму данных и нагрузке на систему. Поэтому часто выбирают только нужные столбцы.

```sql
SELECT name, surname FROM poteshnye_polki;
```

Так мы выберем все строки из таблицы `poteshnye_polki`, но только столбцы `name` и `surname`.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Иван, мне достаточно знать имя и фамилию командира в одном столбце и сколько воинов в полку, но с прибавкой 100 новых рекрутов.',
        photo: petr
    },
    {
        name: 'Иван',
        position: 'right',
        text: 'Значит, нужно выбрать имя и фамилию вместе и прибавить 100 к числу солдат?',
        photo: ivan
    },
    {
        name: 'Алексей',
        position: 'left',
        text: 'Верно, Иван. SQL умеет делать арифметику и объединять строки.',
        photo: alexey
    }
]"/>

В SQL можно создавать вычисляемые столбцы, используя арифметические операции: `+`, `-`, `*`, `/` и пр.

```sql
SELECT name, surname, soldiers_count, soldiers_count + 100 AS soldiers_after_recruitment
FROM poteshnye_polki;
```

Здесь прибавляем 100 рекрутов к числу солдат и даём новому столбцу имя soldiers_after_recruitment.

В PostgreSQL строки объединяются оператором ||:

```sql
SELECT name || ' ' || surname AS full_name, location FROM poteshnye_polki;
```

Можно также и комбинировать:

```sql
SELECT name || ' ' || surname AS full_name, soldiers_count + 100 AS soldiers_after_recruitment FROM poteshnye_polki;
```

<Conversation :phrases="[
    {
        name: 'Иван',
        position: 'right',
        text: 'Алексей, а если в таблице несколько одинаковых записей, как убрать повторы?',
        photo: ivan
    },
    {
        name: 'Алексей',
        position: 'left',
        text: 'Для этого есть ключевое слово DISTINCT. Оно удаляет дубликаты.',
        photo: alexey
    }
]"/>

`DISTINCT` — оператор, который возвращает только уникальные строки по выбранным столбцам.

В теории реляционной алгебры операция, аналогичная `SELECT`, называется проекцией. Она выбирает из таблицы только указанные столбцы и удаляет дубликаты — то есть в результате остаются только уникальные строки.

В SQL по умолчанию дубликаты не удаляются. Чтобы получить уникальные строки, нужно использовать ключевое слово `DISTINCT`.

Так можно выбрать все уникальные имена из таблицы:

```sql
SELECT DISTINCT name, location FROM poteshnye_polki;
```

А вот пример выбора уникальных сочетаний имени и места:

```sql
SELECT DISTINCT name, location FROM poteshnye_polki;
```

PostgreSQL расширяет стандарт SQL и позволяет выбирать уникальные строки по одному или нескольким столбцам с помощью `DISTINCT ON`. Это полезно, когда нужно получить по одной записи на каждое уникальное значение, сохраняя остальные столбцы.

Допустим, нужно получить по одной записи для каждого уникального значения в столбце `is_historical` (то есть выбрать по одному полку для исторических и вымышленных):

```sql
SELECT DISTINCT ON (is_historical) id, name, surname, location, is_historical
FROM poteshnye_polki;
```

Здесь мы берем по одной записи для каждого значения колонки is_historical. Поскольку сортировка не задана, выборка может быть произвольной записи для каждой группы. Запросы с `DISTINCT ON` чаще делают совместно с сортировкой.

<Conversation :phrases="[
    {
        name: 'Петр',
        position: 'left',
        text: 'Алексей, ведомость давайте с названиями столбцов на русском, чтобы легче было читать.',
        photo: petr
    }
]"/>

В SQL можно переименовывать столбцы в выводе с помощью оператора AS.

```sql
SELECT name || ' ' || surname AS "ФИО командира", soldiers_count + 100 AS "Число воинов"
FROM poteshnye_polki;
```

<Conversation :phrases="[
    {
        name: 'Иван',
        position: 'right',
        text: 'Алексей, а можно в запросе добавить условие, чтобы, например, если солдат больше 1000, писать «Большой полк», а иначе — «Малый»?',
        photo: ivan
    },
    {
        name: 'Алексей',
        position: 'left',
        text: 'Конечно! Для этого есть конструкция CASE WHEN.',
        photo: alexey
    }
]"/>

`CASE WHEN` — условный оператор в SQL, который позволяет создавать вычисляемые столбцы с логикой.

```sql
CASE
  WHEN условие THEN значение1
  ELSE значение2
END
```

Пример:

```sql
SELECT name || ' ' || surname AS "ФИО командира",
       soldiers_count,
       CASE
         WHEN soldiers_count > 1000 THEN 'Большой полк'
         ELSE 'Малый полк'
       END AS "Тип полка"
FROM poteshnye_polki;
```

Этот запрос выводит полное имя командира (объединяет имя и фамилию через пробел), количество солдат в полку и добавляет новый столбец с названием "Тип полка". В этом столбце для полков с численностью больше 1000 пишется "Большой полк", а для остальных — "Малый полк".

# Фильтрация данных. Поиск по шаблону

# Сортировка и группировка данных
