# Установка библиотек и подключение баз данных PostgreSQL и Mongodb к приложению

## Введение

В рамках этого учебного курса мы будем разрабатывать **веб-приложение с использованием Node.js и базы данных PostgreSQL**.
Для взаимодействия между приложением и базой данных мы будем использовать официальную библиотеку [`pg`](https://www.npmjs.com/package/pg).

**`node-postgres` (или просто `pg`)** — это набор модулей для Node.js, предназначенных для работы с PostgreSQL.
Она предоставляет удобные инструменты для выполнения SQL-запросов, управления подключениями и обработки результатов.

Библиотека поддерживает:

- колбэки, промисы и `async/await`;
- пул подключений (connection pooling);
- подготовленные запросы (prepared statements);
- курсоры;
- потоковую обработку данных (streaming results);
- интеграцию с C/C++;
- расширенный парсинг типов данных PostgreSQL.

Как и сама PostgreSQL, `pg` предлагает широкий набор возможностей. Документация к библиотеке помогает быстро начать работу, а также содержит материалы по более сложным и специализированным темам.
Благодаря этому мы сможем использовать **всю мощь PostgreSQL прямо из кода на Node.js** — просто, эффективно и без необходимости использовать ORM.

## Основы API библиотеки `pg`

Библиотека `pg` предоставляет несколько ключевых интерфейсов для работы с PostgreSQL.
В этом разделе мы рассмотрим три основных компонента:

1. `Client` — прямое подключение к базе данных;
2. `Pool` — пул подключений (наиболее часто используемый вариант);
3. `Result` — структура данных, возвращаемая после выполнения SQL-запроса.

---

### 1. `Client`: подключение напрямую

Объект `Client` позволяет установить **одно явное соединение** с базой данных PostgreSQL.
Это базовый интерфейс, полезный для выполнения небольших одноразовых операций или настройки транзакций вручную.

#### Пример:

```js
import { Client } from "pg";

const client = new Client({
  host: "localhost",
  port: 5432,
  user: "postgres",
  password: "secret",
  database: "mydb",
});

await client.connect();

const res = await client.query("SELECT NOW()");
console.log(res.rows[0]);

await client.end();
```

#### Особенности:

- Каждое соединение создаётся вручную через `connect()` и закрывается через `end()`.

- Используется в ситуациях, когда нужен полный контроль над соединением.

Объект `Client` создается с помощью конструктора `new Client(config: Config)`, который принимает следующие параметры:

```js
type Config = {
  user?: string, // по умолчанию: process.env.PGUSER или process.env.USER
  password?: string или function, // по умолчанию: process.env.PGPASSWORD
  host?: string, // по умолчанию: process.env.PGHOST
  port?: number, // по умолчанию: process.env.PGPORT
  database?: string, // по умолчанию: process.env.PGDATABASE или user
  connectionString?: string, // например: postgres://user:password@host:5432/database
  ssl?: any, // передаётся напрямую в node.TLSSocket, поддерживает все опции tls.connect
  types?: any, // пользовательские парсеры типов PostgreSQL
  statement_timeout?: number, // максимальное время выполнения SQL-оператора в миллисекундах (по умолчанию — без ограничения)
  query_timeout?: number, // максимальное время выполнения запроса (по умолчанию — без ограничения)
  lock_timeout?: number, // сколько миллисекунд запрос может находиться в блокировке перед отменой (по умолчанию — без ограничения)
  application_name?: string, // имя приложения, которое использует этот экземпляр Client
  connectionTimeoutMillis?: number, // максимальное время ожидания подключения (по умолчанию — без ограничения)
  idle_in_transaction_session_timeout?: number // время (в мс), после которого будет завершена сессия с открытой, но бездействующей транзакцией
}

```

### 2. `Pool`: пул подключений (рекомендуемый способ)

Объект `Pool` управляет множеством подключений к базе данных. Это наиболее эффективный и стабильный способ подключения в реальных веб-приложениях.

#### Пример:

```js
import { Pool } from "pg";

const pool = new Pool({
  host: "localhost",
  port: 5432,
  user: "postgres",
  password: "secret",
  database: "mydb",
});

const result = await pool.query("SELECT * FROM users WHERE id = $1", [1]);
console.log(result.rows[0]);
```

#### Преимущества:

- Пул автоматически управляет соединениями.

- Повторно использует уже открытые подключения.

- Подходит для приложений с высокой нагрузкой.

Пул соединений создается с помощью конструктора `new Pool(config: Config)`, который принимает следующие параметры:

```js
type Config = {
  // все параметры, допустимые для конфигурации клиента (Client), также допустимы здесь

  // дополнительные параметры, специфичные для пула подключений:

  // количество миллисекунд, в течение которых будет ожидаться подключение нового клиента
  // по умолчанию 0 — то есть ожидание не ограничено по времени
  connectionTimeoutMillis?: number

  // количество миллисекунд, которое клиент может находиться в состоянии простоя в пуле,
  // прежде чем он будет отключён от сервера и удалён из пула
  // по умолчанию 10000 (10 секунд); установите 0, чтобы отключить автоматическое удаление
  idleTimeoutMillis?: number

  // максимальное количество клиентов, которое может содержать пул
  // по умолчанию установлено значение 10
  max?: number

  // По умолчанию пул будет держать клиентов подключёнными к серверу PostgreSQL,
  // пока не истечёт idleTimeoutMillis, при этом Node.js будет поддерживать ссылку на сокет,
  // из-за чего event loop (цикл событий) не завершится, пока клиенты не будут закрыты вручную
  // или не отключатся сами по истечении времени простоя.

  // Если установить параметр `allowExitOnIdle: true`, то цикл событий Node.js завершится
  // сразу после того, как все клиенты в пуле перейдут в режим ожидания,
  // даже если сокеты всё ещё остаются открытыми.
  // Это удобно, например, в скриптах или тестах, где не хочется ждать,
  // пока все подключения станут неактивными.
  allowExitOnIdle?: boolean
}
```

Пул изначально создаётся пустым и будет лениво создавать новые подключения (клиенты) по мере необходимости. Каждое поле объекта конфигурации является полностью необязательным. Конфигурация, переданная пулу, также автоматически передаётся каждому клиенту, который создаётся внутри этого пула.

### 3. Result: результат выполнения SQL-запроса

Метод `query(...)` возвращает объект результата со следующей структурой:

```js
{
  rows: Array<any>,         // массив строк результата
  rowCount: number,         // количество строк
  command: string,          // тип SQL-команды (например, SELECT, UPDATE)
  fields: Array<FieldInfo>  // информация о колонках
}
```

#### Пример запроса:

```js
import pg from 'pg'
const { Pool } = pg

const pool = new Pool()

const client = await pool.connect()
const result = await client.query({
  rowMode: 'array',
  text: 'SELECT 1 as one, 2 as two;',
})
console.log(result.fields[0].name) // one
console.log(result.fields[1].name) // two
console.log(result.rows) // [ [ 1, 2 ] ]
await client.end()
```

# Разработка интерфейса взаимодействия с пользователем
